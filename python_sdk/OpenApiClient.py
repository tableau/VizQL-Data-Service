# generated by datamodel-codegen:
#   filename:  VizQLDataServiceOpenAPISchema.json
#   timestamp: 2025-05-16T17:38:19+00:00

from __future__ import annotations

from datetime import date
from datetime import datetime as datetime_aliased
from enum import Enum
from typing import Annotated, Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class TableauError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    errorCode: Optional[str] = None
    message: Optional[str] = None
    datetime: Optional[datetime_aliased] = None
    debug: Optional[Dict[str, Any]] = None
    tab_error_code: Annotated[Optional[str], Field(alias='tab-error-code')] = None


class DataType(Enum):
    INTEGER = 'INTEGER'
    REAL = 'REAL'
    STRING = 'STRING'
    DATETIME = 'DATETIME'
    BOOLEAN = 'BOOLEAN'
    DATE = 'DATE'
    SPATIAL = 'SPATIAL'
    UNKNOWN = 'UNKNOWN'


class FieldMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    fieldName: Optional[str] = None
    fieldCaption: Optional[str] = None
    dataType: Optional[DataType] = None
    logicalTableId: Optional[str] = None


class Connection(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    connectionLuid: Optional[str] = None
    connectionUsername: str
    connectionPassword: str


class Datasource(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    datasourceLuid: Annotated[
        str, Field(description='The LUID of the data source to be queried.')
    ]
    connections: Optional[List[Connection]] = None


class FilterType(Enum):
    QUANTITATIVE_DATE = 'QUANTITATIVE_DATE'
    QUANTITATIVE_NUMERICAL = 'QUANTITATIVE_NUMERICAL'
    SET = 'SET'
    MATCH = 'MATCH'
    DATE = 'DATE'
    TOP = 'TOP'


class FilterSimpleField(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    fieldCaption: Annotated[
        str, Field(description='The caption of the field to filter on.')
    ]


class FilterCalculatedField(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    calculation: Annotated[
        str, Field(description='A Tableau calculation that will be used to filter on.')
    ]


class Function(Enum):
    SUM = 'SUM'
    AVG = 'AVG'
    MEDIAN = 'MEDIAN'
    COUNT = 'COUNT'
    COUNTD = 'COUNTD'
    MIN = 'MIN'
    MAX = 'MAX'
    STDEV = 'STDEV'
    VAR = 'VAR'
    COLLECT = 'COLLECT'
    YEAR = 'YEAR'
    QUARTER = 'QUARTER'
    MONTH = 'MONTH'
    WEEK = 'WEEK'
    DAY = 'DAY'
    TRUNC_YEAR = 'TRUNC_YEAR'
    TRUNC_QUARTER = 'TRUNC_QUARTER'
    TRUNC_MONTH = 'TRUNC_MONTH'
    TRUNC_WEEK = 'TRUNC_WEEK'
    TRUNC_DAY = 'TRUNC_DAY'


class MetadataOutput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    data: Optional[List[FieldMetadata]] = None


class QuantitativeFilterType(Enum):
    RANGE = 'RANGE'
    MIN = 'MIN'
    MAX = 'MAX'
    ONLY_NULL = 'ONLY_NULL'
    ONLY_NON_NULL = 'ONLY_NON_NULL'


class QueryOutput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    data: Optional[List] = None


class ReturnFormat(Enum):
    OBJECTS = 'OBJECTS'
    ARRAYS = 'ARRAYS'


class SortDirection(Enum):
    ASC = 'ASC'
    DESC = 'DESC'


class PeriodType(Enum):
    MINUTES = 'MINUTES'
    HOURS = 'HOURS'
    DAYS = 'DAYS'
    WEEKS = 'WEEKS'
    MONTHS = 'MONTHS'
    QUARTERS = 'QUARTERS'
    YEARS = 'YEARS'


class DateRangeType(Enum):
    CURRENT = 'CURRENT'
    LAST = 'LAST'
    LASTN = 'LASTN'
    NEXT = 'NEXT'
    NEXTN = 'NEXTN'
    TODATE = 'TODATE'


class Direction(Enum):
    TOP = 'TOP'
    BOTTOM = 'BOTTOM'


class FieldBase(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    fieldCaption: Annotated[
        str,
        Field(
            description='Either the name of a specific Field in the data source, or, in the case of a calculation, a user-supplied name for the calculation.'
        ),
    ]
    fieldAlias: Annotated[
        Optional[str],
        Field(
            description='An alternative name to give the field. Will only be used in object format output.'
        ),
    ] = None
    maxDecimalPlaces: Annotated[
        Optional[int],
        Field(
            description='The maximum number of decimal places. Any trailing 0s will be dropped. The maxDecimalPlaces value must be greater or equal to 0.'
        ),
    ] = None
    sortDirection: Optional[SortDirection] = None
    sortPriority: Annotated[
        Optional[int],
        Field(
            description='To enable sorting on a specific Field, provide a sortPriority for that field, and that field will be sorted. The sortPriority provides a ranking of how to sort fields when multiple fields are being sorted. The highest priority (lowest number) field is sorted first. If only one field is being sorted, then any value may be used for sortPriority. SortPriority should be an integer greater than 0.'
        ),
    ] = None


class SimpleField(FieldBase):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    fieldCaption: Optional[Any] = None
    fieldAlias: Optional[Any] = None
    maxDecimalPlaces: Optional[Any] = None
    sortDirection: Optional[Any] = None
    sortPriority: Optional[Any] = None


class AggregatedField(FieldBase):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    function: Function
    fieldCaption: Optional[Any] = None
    fieldAlias: Optional[Any] = None
    maxDecimalPlaces: Optional[Any] = None
    sortDirection: Optional[Any] = None
    sortPriority: Optional[Any] = None


class CalculatedField(FieldBase):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    calculation: Annotated[
        str,
        Field(
            description='A Tableau calculation that will be returned as a Field in the query.'
        ),
    ]
    fieldCaption: Optional[Any] = None
    fieldAlias: Optional[Any] = None
    maxDecimalPlaces: Optional[Any] = None
    sortDirection: Optional[Any] = None
    sortPriority: Optional[Any] = None


class TabField(RootModel[Union[SimpleField, AggregatedField, CalculatedField]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[SimpleField, AggregatedField, CalculatedField]


class FilterAggregatedField(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    fieldCaption: Annotated[
        str, Field(description='The caption of the field to filter on.')
    ]
    function: Function


class FilterField(RootModel[Union[FilterSimpleField, FilterAggregatedField, FilterCalculatedField]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[FilterSimpleField, FilterAggregatedField, FilterCalculatedField]


class QueryOptions(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    returnFormat: Optional[ReturnFormat] = None
    debug: Optional[bool] = False


class ReadMetadataRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    datasource: Datasource
    options: Optional[QueryOptions] = None


class Filter(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field: FilterField
    filterType: FilterType
    context: Annotated[
        Optional[bool],
        Field(
            description="Make the given filter a context filter, meaning that it's an independent filter. Any other filters that you set are defined as dependent filters because they process only the data that passes through the context filter."
        ),
    ] = False


class MatchFilter(Filter):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    contains: Annotated[
        Optional[str], Field(description='Matches when a field contains this value.')
    ] = None
    startsWith: Annotated[
        Optional[str], Field(description='Matches when a field starts with this value.')
    ] = None
    endsWith: Annotated[
        Optional[str], Field(description='Matches when a field ends with this value.')
    ] = None
    exclude: Annotated[
        Optional[bool],
        Field(description='When true, the inverse of the matching logic will be used.'),
    ] = False


class QuantitativeFilterBase(Filter):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    quantitativeFilterType: QuantitativeFilterType
    includeNulls: Annotated[
        Optional[bool],
        Field(
            description='Should nulls be returned or not. Only applies to RANGE, MIN, and MAX filters. If not provided, the default is to not include null values.'
        ),
    ] = None


class QuantitativeNumericalFilter(QuantitativeFilterBase):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    min: Annotated[
        Optional[float],
        Field(
            description='A numerical value, either integer or floating point, indicating the minimum value to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN.'
        ),
    ] = None
    max: Annotated[
        Optional[float],
        Field(
            description='A numerical value, either integer or floating point, indicating the maximum value to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN.'
        ),
    ] = None


class QuantitativeDateFilter(QuantitativeFilterBase):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    minDate: Annotated[
        Optional[date],
        Field(
            description='An RFC 3339 date indicating the earliest date to filter upon. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN.'
        ),
    ] = None
    maxDate: Annotated[
        Optional[date],
        Field(
            description='An RFC 3339 date indicating the latest date to filter on. Required if using quantitativeFilterType RANGE or if using quantitativeFilterType MIN.'
        ),
    ] = None


class Query(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    fields: Annotated[
        List[TabField], Field(description='An array of fields that define the query.')
    ]
    filters: Annotated[
        Optional[List[Filter]],
        Field(description='An optional array of filters to apply to the query.'),
    ] = None


class QueryDatasourceOptions(QueryOptions):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    disaggregate: Optional[bool] = False


class QueryRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    datasource: Datasource
    query: Query
    options: Optional[QueryDatasourceOptions] = None


class SetFilter(Filter):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    values: Annotated[List, Field(description='An array of values to filter on.')]
    exclude: Optional[bool] = False


class RelativeDateFilter(Filter):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    periodType: Annotated[
        PeriodType, Field(description='The units of time in the relative date range.')
    ]
    dateRangeType: Annotated[
        DateRangeType, Field(description='The direction in the relative date range.')
    ]
    rangeN: Annotated[
        Optional[int],
        Field(
            description='When dateRangeType is LASTN or NEXTN, this is the N value (how many years, months, etc.).'
        ),
    ] = None
    anchorDate: Annotated[
        Optional[date],
        Field(
            description="If a value for this field isn't provided, the value defaults to today."
        ),
    ] = None
    includeNulls: Annotated[
        Optional[bool],
        Field(
            description="Should nulls be returned or not. If a value isn't provided, the default is to not include null values."
        ),
    ] = None


class TopNFilter(Filter):
    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    direction: Annotated[
        Optional[Direction],
        Field(description='Top (ascending) or Bottom (descending) N.'),
    ] = 'TOP'
    howMany: Annotated[
        Optional[int],
        Field(
            description='The number of values from the top or the bottom of the given fieldToMeasure.'
        ),
    ] = None
    fieldToMeasure: Optional[FilterField] = None

class TabFilter(RootModel[Union[
    MatchFilter, QuantitativeNumericalFilter, QuantitativeDateFilter, SetFilter, RelativeDateFilter, TopNFilter]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        MatchFilter, QuantitativeNumericalFilter, QuantitativeDateFilter, SetFilter, RelativeDateFilter, TopNFilter]